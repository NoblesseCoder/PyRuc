Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    lparen
    logic
    logicnot
    rparen
    comment
    keywords
    append
    string
    builtinmethod
    range
    rsquare
    lsquare
    lflower
    rflower
    begin
    break
    for
    true
    false
    return
    in
    quotes
    dollar
    commas
    bar

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> BLOCKSTMT
Rule 2     BLOCKSTMT -> STMT newline BLOCKSTMT
Rule 3     BLOCKSTMT -> STMT newline
Rule 4     BLOCKSTMT -> STMT
Rule 5     BLOCKSTMT -> STMT BLOCKSTMT
Rule 6     T -> newline
Rule 7     T -> <empty>
Rule 8     STMT -> ASSGN
Rule 9     STMT -> SELECT
Rule 10    STMT -> ITER
Rule 11    SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER
Rule 12    EMPTQC -> <empty>
Rule 13    LABELMAKER -> <empty>
Rule 14    ELSIF -> elsif CONDEXPR then_tok T BLOCKSTMT LABELMAKER
Rule 15    ELSIF -> <empty>
Rule 16    ELSE -> else BLOCKSTMT
Rule 17    ELSE -> <empty>
Rule 18    CONDEXPR -> EXPR less EXPR
Rule 19    CONDEXPR -> EXPR equals equals EXPR
Rule 20    CONDEXPR -> EXPR great EXPR
Rule 21    CONDEXPR -> EXPR great equals EXPR
Rule 22    CONDEXPR -> EXPR less equals EXPR
Rule 23    ASSGN -> LHS equals EXPR
Rule 24    LHS -> name
Rule 25    EXPR -> EXPR plus EXPR
Rule 26    EXPR -> EXPR minus EXPR
Rule 27    EXPR -> EXPR times EXPR
Rule 28    EXPR -> EXPR divide EXPR
Rule 29    EXPR -> name
Rule 30    EXPR -> number
Rule 31    ITER -> while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER

Terminals, with rules where they appear

append               : 
bar                  : 
begin                : 
break                : 
builtinmethod        : 
commas               : 
comment              : 
divide               : 28
do                   : 31
dollar               : 
else                 : 16
elsif                : 14
end                  : 11 31
equals               : 19 19 21 22 23
error                : 
false                : 
for                  : 
great                : 20 21
if                   : 11
in                   : 
keywords             : 
less                 : 18 22
lflower              : 
logic                : 
logicnot             : 
lparen               : 
lsquare              : 
minus                : 26
name                 : 24 29
newline              : 2 3 6
number               : 30
plus                 : 25
quotes               : 
range                : 
return               : 
rflower              : 
rparen               : 
rsquare              : 
string               : 
then_tok             : 11 14
times                : 27
true                 : 
while                : 31

Nonterminals, with rules where they appear

ASSGN                : 8
BLOCKSTMT            : 1 2 5 11 14 16 31
CONDEXPR             : 11 14 31
ELSE                 : 11
ELSIF                : 11
EMPTQC               : 11
EXPR                 : 18 18 19 19 20 20 21 21 22 22 23 25 25 26 26 27 27 28 28
ITER                 : 10
LABELMAKER           : 11 11 14 31 31
LHS                  : 23
PROGRAM              : 0
SELECT               : 9
STMT                 : 2 3 4 5
T                    : 11 11 14 31 31

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . BLOCKSTMT
    (2) BLOCKSTMT -> . STMT newline BLOCKSTMT
    (3) BLOCKSTMT -> . STMT newline
    (4) BLOCKSTMT -> . STMT
    (5) BLOCKSTMT -> . STMT BLOCKSTMT
    (8) STMT -> . ASSGN
    (9) STMT -> . SELECT
    (10) STMT -> . ITER
    (23) ASSGN -> . LHS equals EXPR
    (11) SELECT -> . if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER
    (31) ITER -> . while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER
    (24) LHS -> . name

    if              shift and go to state 8
    while           shift and go to state 9
    name            shift and go to state 10

    PROGRAM                        shift and go to state 1
    BLOCKSTMT                      shift and go to state 2
    STMT                           shift and go to state 3
    ASSGN                          shift and go to state 4
    SELECT                         shift and go to state 5
    ITER                           shift and go to state 6
    LHS                            shift and go to state 7

state 1

    (0) S' -> PROGRAM .



state 2

    (1) PROGRAM -> BLOCKSTMT .

    $end            reduce using rule 1 (PROGRAM -> BLOCKSTMT .)


state 3

    (2) BLOCKSTMT -> STMT . newline BLOCKSTMT
    (3) BLOCKSTMT -> STMT . newline
    (4) BLOCKSTMT -> STMT .
    (5) BLOCKSTMT -> STMT . BLOCKSTMT
    (2) BLOCKSTMT -> . STMT newline BLOCKSTMT
    (3) BLOCKSTMT -> . STMT newline
    (4) BLOCKSTMT -> . STMT
    (5) BLOCKSTMT -> . STMT BLOCKSTMT
    (8) STMT -> . ASSGN
    (9) STMT -> . SELECT
    (10) STMT -> . ITER
    (23) ASSGN -> . LHS equals EXPR
    (11) SELECT -> . if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER
    (31) ITER -> . while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER
    (24) LHS -> . name

  ! shift/reduce conflict for newline resolved as shift
    newline         shift and go to state 11
    $end            reduce using rule 4 (BLOCKSTMT -> STMT .)
    elsif           reduce using rule 4 (BLOCKSTMT -> STMT .)
    else            reduce using rule 4 (BLOCKSTMT -> STMT .)
    end             reduce using rule 4 (BLOCKSTMT -> STMT .)
    if              shift and go to state 8
    while           shift and go to state 9
    name            shift and go to state 10

  ! newline         [ reduce using rule 4 (BLOCKSTMT -> STMT .) ]

    STMT                           shift and go to state 3
    BLOCKSTMT                      shift and go to state 12
    ASSGN                          shift and go to state 4
    SELECT                         shift and go to state 5
    ITER                           shift and go to state 6
    LHS                            shift and go to state 7

state 4

    (8) STMT -> ASSGN .

    newline         reduce using rule 8 (STMT -> ASSGN .)
    if              reduce using rule 8 (STMT -> ASSGN .)
    while           reduce using rule 8 (STMT -> ASSGN .)
    name            reduce using rule 8 (STMT -> ASSGN .)
    $end            reduce using rule 8 (STMT -> ASSGN .)
    elsif           reduce using rule 8 (STMT -> ASSGN .)
    else            reduce using rule 8 (STMT -> ASSGN .)
    end             reduce using rule 8 (STMT -> ASSGN .)


state 5

    (9) STMT -> SELECT .

    newline         reduce using rule 9 (STMT -> SELECT .)
    if              reduce using rule 9 (STMT -> SELECT .)
    while           reduce using rule 9 (STMT -> SELECT .)
    name            reduce using rule 9 (STMT -> SELECT .)
    $end            reduce using rule 9 (STMT -> SELECT .)
    elsif           reduce using rule 9 (STMT -> SELECT .)
    else            reduce using rule 9 (STMT -> SELECT .)
    end             reduce using rule 9 (STMT -> SELECT .)


state 6

    (10) STMT -> ITER .

    newline         reduce using rule 10 (STMT -> ITER .)
    if              reduce using rule 10 (STMT -> ITER .)
    while           reduce using rule 10 (STMT -> ITER .)
    name            reduce using rule 10 (STMT -> ITER .)
    $end            reduce using rule 10 (STMT -> ITER .)
    elsif           reduce using rule 10 (STMT -> ITER .)
    else            reduce using rule 10 (STMT -> ITER .)
    end             reduce using rule 10 (STMT -> ITER .)


state 7

    (23) ASSGN -> LHS . equals EXPR

    equals          shift and go to state 13


state 8

    (11) SELECT -> if . CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER
    (18) CONDEXPR -> . EXPR less EXPR
    (19) CONDEXPR -> . EXPR equals equals EXPR
    (20) CONDEXPR -> . EXPR great EXPR
    (21) CONDEXPR -> . EXPR great equals EXPR
    (22) CONDEXPR -> . EXPR less equals EXPR
    (25) EXPR -> . EXPR plus EXPR
    (26) EXPR -> . EXPR minus EXPR
    (27) EXPR -> . EXPR times EXPR
    (28) EXPR -> . EXPR divide EXPR
    (29) EXPR -> . name
    (30) EXPR -> . number

    name            shift and go to state 16
    number          shift and go to state 17

    CONDEXPR                       shift and go to state 14
    EXPR                           shift and go to state 15

state 9

    (31) ITER -> while . LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER
    (13) LABELMAKER -> .

    name            reduce using rule 13 (LABELMAKER -> .)
    number          reduce using rule 13 (LABELMAKER -> .)

    LABELMAKER                     shift and go to state 18

state 10

    (24) LHS -> name .

    equals          reduce using rule 24 (LHS -> name .)


state 11

    (2) BLOCKSTMT -> STMT newline . BLOCKSTMT
    (3) BLOCKSTMT -> STMT newline .
    (2) BLOCKSTMT -> . STMT newline BLOCKSTMT
    (3) BLOCKSTMT -> . STMT newline
    (4) BLOCKSTMT -> . STMT
    (5) BLOCKSTMT -> . STMT BLOCKSTMT
    (8) STMT -> . ASSGN
    (9) STMT -> . SELECT
    (10) STMT -> . ITER
    (23) ASSGN -> . LHS equals EXPR
    (11) SELECT -> . if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER
    (31) ITER -> . while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER
    (24) LHS -> . name

    $end            reduce using rule 3 (BLOCKSTMT -> STMT newline .)
    newline         reduce using rule 3 (BLOCKSTMT -> STMT newline .)
    elsif           reduce using rule 3 (BLOCKSTMT -> STMT newline .)
    else            reduce using rule 3 (BLOCKSTMT -> STMT newline .)
    end             reduce using rule 3 (BLOCKSTMT -> STMT newline .)
    if              shift and go to state 8
    while           shift and go to state 9
    name            shift and go to state 10

    STMT                           shift and go to state 3
    BLOCKSTMT                      shift and go to state 19
    ASSGN                          shift and go to state 4
    SELECT                         shift and go to state 5
    ITER                           shift and go to state 6
    LHS                            shift and go to state 7

state 12

    (5) BLOCKSTMT -> STMT BLOCKSTMT .

    $end            reduce using rule 5 (BLOCKSTMT -> STMT BLOCKSTMT .)
    newline         reduce using rule 5 (BLOCKSTMT -> STMT BLOCKSTMT .)
    elsif           reduce using rule 5 (BLOCKSTMT -> STMT BLOCKSTMT .)
    else            reduce using rule 5 (BLOCKSTMT -> STMT BLOCKSTMT .)
    end             reduce using rule 5 (BLOCKSTMT -> STMT BLOCKSTMT .)


state 13

    (23) ASSGN -> LHS equals . EXPR
    (25) EXPR -> . EXPR plus EXPR
    (26) EXPR -> . EXPR minus EXPR
    (27) EXPR -> . EXPR times EXPR
    (28) EXPR -> . EXPR divide EXPR
    (29) EXPR -> . name
    (30) EXPR -> . number

    name            shift and go to state 16
    number          shift and go to state 17

    EXPR                           shift and go to state 20

state 14

    (11) SELECT -> if CONDEXPR . EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER
    (12) EMPTQC -> .

    then_tok        reduce using rule 12 (EMPTQC -> .)

    EMPTQC                         shift and go to state 21

state 15

    (18) CONDEXPR -> EXPR . less EXPR
    (19) CONDEXPR -> EXPR . equals equals EXPR
    (20) CONDEXPR -> EXPR . great EXPR
    (21) CONDEXPR -> EXPR . great equals EXPR
    (22) CONDEXPR -> EXPR . less equals EXPR
    (25) EXPR -> EXPR . plus EXPR
    (26) EXPR -> EXPR . minus EXPR
    (27) EXPR -> EXPR . times EXPR
    (28) EXPR -> EXPR . divide EXPR

    less            shift and go to state 22
    equals          shift and go to state 23
    great           shift and go to state 24
    plus            shift and go to state 25
    minus           shift and go to state 26
    times           shift and go to state 27
    divide          shift and go to state 28


state 16

    (29) EXPR -> name .

    less            reduce using rule 29 (EXPR -> name .)
    equals          reduce using rule 29 (EXPR -> name .)
    great           reduce using rule 29 (EXPR -> name .)
    plus            reduce using rule 29 (EXPR -> name .)
    minus           reduce using rule 29 (EXPR -> name .)
    times           reduce using rule 29 (EXPR -> name .)
    divide          reduce using rule 29 (EXPR -> name .)
    newline         reduce using rule 29 (EXPR -> name .)
    if              reduce using rule 29 (EXPR -> name .)
    while           reduce using rule 29 (EXPR -> name .)
    name            reduce using rule 29 (EXPR -> name .)
    $end            reduce using rule 29 (EXPR -> name .)
    elsif           reduce using rule 29 (EXPR -> name .)
    else            reduce using rule 29 (EXPR -> name .)
    end             reduce using rule 29 (EXPR -> name .)
    then_tok        reduce using rule 29 (EXPR -> name .)
    do              reduce using rule 29 (EXPR -> name .)


state 17

    (30) EXPR -> number .

    less            reduce using rule 30 (EXPR -> number .)
    equals          reduce using rule 30 (EXPR -> number .)
    great           reduce using rule 30 (EXPR -> number .)
    plus            reduce using rule 30 (EXPR -> number .)
    minus           reduce using rule 30 (EXPR -> number .)
    times           reduce using rule 30 (EXPR -> number .)
    divide          reduce using rule 30 (EXPR -> number .)
    newline         reduce using rule 30 (EXPR -> number .)
    if              reduce using rule 30 (EXPR -> number .)
    while           reduce using rule 30 (EXPR -> number .)
    name            reduce using rule 30 (EXPR -> number .)
    $end            reduce using rule 30 (EXPR -> number .)
    elsif           reduce using rule 30 (EXPR -> number .)
    else            reduce using rule 30 (EXPR -> number .)
    end             reduce using rule 30 (EXPR -> number .)
    then_tok        reduce using rule 30 (EXPR -> number .)
    do              reduce using rule 30 (EXPR -> number .)


state 18

    (31) ITER -> while LABELMAKER . CONDEXPR do T BLOCKSTMT T end LABELMAKER
    (18) CONDEXPR -> . EXPR less EXPR
    (19) CONDEXPR -> . EXPR equals equals EXPR
    (20) CONDEXPR -> . EXPR great EXPR
    (21) CONDEXPR -> . EXPR great equals EXPR
    (22) CONDEXPR -> . EXPR less equals EXPR
    (25) EXPR -> . EXPR plus EXPR
    (26) EXPR -> . EXPR minus EXPR
    (27) EXPR -> . EXPR times EXPR
    (28) EXPR -> . EXPR divide EXPR
    (29) EXPR -> . name
    (30) EXPR -> . number

    name            shift and go to state 16
    number          shift and go to state 17

    CONDEXPR                       shift and go to state 29
    EXPR                           shift and go to state 15

state 19

    (2) BLOCKSTMT -> STMT newline BLOCKSTMT .

    $end            reduce using rule 2 (BLOCKSTMT -> STMT newline BLOCKSTMT .)
    newline         reduce using rule 2 (BLOCKSTMT -> STMT newline BLOCKSTMT .)
    elsif           reduce using rule 2 (BLOCKSTMT -> STMT newline BLOCKSTMT .)
    else            reduce using rule 2 (BLOCKSTMT -> STMT newline BLOCKSTMT .)
    end             reduce using rule 2 (BLOCKSTMT -> STMT newline BLOCKSTMT .)


state 20

    (23) ASSGN -> LHS equals EXPR .
    (25) EXPR -> EXPR . plus EXPR
    (26) EXPR -> EXPR . minus EXPR
    (27) EXPR -> EXPR . times EXPR
    (28) EXPR -> EXPR . divide EXPR

    newline         reduce using rule 23 (ASSGN -> LHS equals EXPR .)
    if              reduce using rule 23 (ASSGN -> LHS equals EXPR .)
    while           reduce using rule 23 (ASSGN -> LHS equals EXPR .)
    name            reduce using rule 23 (ASSGN -> LHS equals EXPR .)
    $end            reduce using rule 23 (ASSGN -> LHS equals EXPR .)
    elsif           reduce using rule 23 (ASSGN -> LHS equals EXPR .)
    else            reduce using rule 23 (ASSGN -> LHS equals EXPR .)
    end             reduce using rule 23 (ASSGN -> LHS equals EXPR .)
    plus            shift and go to state 25
    minus           shift and go to state 26
    times           shift and go to state 27
    divide          shift and go to state 28


state 21

    (11) SELECT -> if CONDEXPR EMPTQC . then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER

    then_tok        shift and go to state 30


state 22

    (18) CONDEXPR -> EXPR less . EXPR
    (22) CONDEXPR -> EXPR less . equals EXPR
    (25) EXPR -> . EXPR plus EXPR
    (26) EXPR -> . EXPR minus EXPR
    (27) EXPR -> . EXPR times EXPR
    (28) EXPR -> . EXPR divide EXPR
    (29) EXPR -> . name
    (30) EXPR -> . number

    equals          shift and go to state 32
    name            shift and go to state 16
    number          shift and go to state 17

    EXPR                           shift and go to state 31

state 23

    (19) CONDEXPR -> EXPR equals . equals EXPR

    equals          shift and go to state 33


state 24

    (20) CONDEXPR -> EXPR great . EXPR
    (21) CONDEXPR -> EXPR great . equals EXPR
    (25) EXPR -> . EXPR plus EXPR
    (26) EXPR -> . EXPR minus EXPR
    (27) EXPR -> . EXPR times EXPR
    (28) EXPR -> . EXPR divide EXPR
    (29) EXPR -> . name
    (30) EXPR -> . number

    equals          shift and go to state 35
    name            shift and go to state 16
    number          shift and go to state 17

    EXPR                           shift and go to state 34

state 25

    (25) EXPR -> EXPR plus . EXPR
    (25) EXPR -> . EXPR plus EXPR
    (26) EXPR -> . EXPR minus EXPR
    (27) EXPR -> . EXPR times EXPR
    (28) EXPR -> . EXPR divide EXPR
    (29) EXPR -> . name
    (30) EXPR -> . number

    name            shift and go to state 16
    number          shift and go to state 17

    EXPR                           shift and go to state 36

state 26

    (26) EXPR -> EXPR minus . EXPR
    (25) EXPR -> . EXPR plus EXPR
    (26) EXPR -> . EXPR minus EXPR
    (27) EXPR -> . EXPR times EXPR
    (28) EXPR -> . EXPR divide EXPR
    (29) EXPR -> . name
    (30) EXPR -> . number

    name            shift and go to state 16
    number          shift and go to state 17

    EXPR                           shift and go to state 37

state 27

    (27) EXPR -> EXPR times . EXPR
    (25) EXPR -> . EXPR plus EXPR
    (26) EXPR -> . EXPR minus EXPR
    (27) EXPR -> . EXPR times EXPR
    (28) EXPR -> . EXPR divide EXPR
    (29) EXPR -> . name
    (30) EXPR -> . number

    name            shift and go to state 16
    number          shift and go to state 17

    EXPR                           shift and go to state 38

state 28

    (28) EXPR -> EXPR divide . EXPR
    (25) EXPR -> . EXPR plus EXPR
    (26) EXPR -> . EXPR minus EXPR
    (27) EXPR -> . EXPR times EXPR
    (28) EXPR -> . EXPR divide EXPR
    (29) EXPR -> . name
    (30) EXPR -> . number

    name            shift and go to state 16
    number          shift and go to state 17

    EXPR                           shift and go to state 39

state 29

    (31) ITER -> while LABELMAKER CONDEXPR . do T BLOCKSTMT T end LABELMAKER

    do              shift and go to state 40


state 30

    (11) SELECT -> if CONDEXPR EMPTQC then_tok . T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER
    (6) T -> . newline
    (7) T -> .

    newline         shift and go to state 42
    if              reduce using rule 7 (T -> .)
    while           reduce using rule 7 (T -> .)
    name            reduce using rule 7 (T -> .)

    T                              shift and go to state 41

state 31

    (18) CONDEXPR -> EXPR less EXPR .
    (25) EXPR -> EXPR . plus EXPR
    (26) EXPR -> EXPR . minus EXPR
    (27) EXPR -> EXPR . times EXPR
    (28) EXPR -> EXPR . divide EXPR

    then_tok        reduce using rule 18 (CONDEXPR -> EXPR less EXPR .)
    do              reduce using rule 18 (CONDEXPR -> EXPR less EXPR .)
    plus            shift and go to state 25
    minus           shift and go to state 26
    times           shift and go to state 27
    divide          shift and go to state 28


state 32

    (22) CONDEXPR -> EXPR less equals . EXPR
    (25) EXPR -> . EXPR plus EXPR
    (26) EXPR -> . EXPR minus EXPR
    (27) EXPR -> . EXPR times EXPR
    (28) EXPR -> . EXPR divide EXPR
    (29) EXPR -> . name
    (30) EXPR -> . number

    name            shift and go to state 16
    number          shift and go to state 17

    EXPR                           shift and go to state 43

state 33

    (19) CONDEXPR -> EXPR equals equals . EXPR
    (25) EXPR -> . EXPR plus EXPR
    (26) EXPR -> . EXPR minus EXPR
    (27) EXPR -> . EXPR times EXPR
    (28) EXPR -> . EXPR divide EXPR
    (29) EXPR -> . name
    (30) EXPR -> . number

    name            shift and go to state 16
    number          shift and go to state 17

    EXPR                           shift and go to state 44

state 34

    (20) CONDEXPR -> EXPR great EXPR .
    (25) EXPR -> EXPR . plus EXPR
    (26) EXPR -> EXPR . minus EXPR
    (27) EXPR -> EXPR . times EXPR
    (28) EXPR -> EXPR . divide EXPR

    then_tok        reduce using rule 20 (CONDEXPR -> EXPR great EXPR .)
    do              reduce using rule 20 (CONDEXPR -> EXPR great EXPR .)
    plus            shift and go to state 25
    minus           shift and go to state 26
    times           shift and go to state 27
    divide          shift and go to state 28


state 35

    (21) CONDEXPR -> EXPR great equals . EXPR
    (25) EXPR -> . EXPR plus EXPR
    (26) EXPR -> . EXPR minus EXPR
    (27) EXPR -> . EXPR times EXPR
    (28) EXPR -> . EXPR divide EXPR
    (29) EXPR -> . name
    (30) EXPR -> . number

    name            shift and go to state 16
    number          shift and go to state 17

    EXPR                           shift and go to state 45

state 36

    (25) EXPR -> EXPR plus EXPR .
    (25) EXPR -> EXPR . plus EXPR
    (26) EXPR -> EXPR . minus EXPR
    (27) EXPR -> EXPR . times EXPR
    (28) EXPR -> EXPR . divide EXPR

    less            reduce using rule 25 (EXPR -> EXPR plus EXPR .)
    equals          reduce using rule 25 (EXPR -> EXPR plus EXPR .)
    great           reduce using rule 25 (EXPR -> EXPR plus EXPR .)
    plus            reduce using rule 25 (EXPR -> EXPR plus EXPR .)
    minus           reduce using rule 25 (EXPR -> EXPR plus EXPR .)
    newline         reduce using rule 25 (EXPR -> EXPR plus EXPR .)
    if              reduce using rule 25 (EXPR -> EXPR plus EXPR .)
    while           reduce using rule 25 (EXPR -> EXPR plus EXPR .)
    name            reduce using rule 25 (EXPR -> EXPR plus EXPR .)
    $end            reduce using rule 25 (EXPR -> EXPR plus EXPR .)
    elsif           reduce using rule 25 (EXPR -> EXPR plus EXPR .)
    else            reduce using rule 25 (EXPR -> EXPR plus EXPR .)
    end             reduce using rule 25 (EXPR -> EXPR plus EXPR .)
    then_tok        reduce using rule 25 (EXPR -> EXPR plus EXPR .)
    do              reduce using rule 25 (EXPR -> EXPR plus EXPR .)
    times           shift and go to state 27
    divide          shift and go to state 28

  ! times           [ reduce using rule 25 (EXPR -> EXPR plus EXPR .) ]
  ! divide          [ reduce using rule 25 (EXPR -> EXPR plus EXPR .) ]
  ! plus            [ shift and go to state 25 ]
  ! minus           [ shift and go to state 26 ]


state 37

    (26) EXPR -> EXPR minus EXPR .
    (25) EXPR -> EXPR . plus EXPR
    (26) EXPR -> EXPR . minus EXPR
    (27) EXPR -> EXPR . times EXPR
    (28) EXPR -> EXPR . divide EXPR

    less            reduce using rule 26 (EXPR -> EXPR minus EXPR .)
    equals          reduce using rule 26 (EXPR -> EXPR minus EXPR .)
    great           reduce using rule 26 (EXPR -> EXPR minus EXPR .)
    plus            reduce using rule 26 (EXPR -> EXPR minus EXPR .)
    minus           reduce using rule 26 (EXPR -> EXPR minus EXPR .)
    newline         reduce using rule 26 (EXPR -> EXPR minus EXPR .)
    if              reduce using rule 26 (EXPR -> EXPR minus EXPR .)
    while           reduce using rule 26 (EXPR -> EXPR minus EXPR .)
    name            reduce using rule 26 (EXPR -> EXPR minus EXPR .)
    $end            reduce using rule 26 (EXPR -> EXPR minus EXPR .)
    elsif           reduce using rule 26 (EXPR -> EXPR minus EXPR .)
    else            reduce using rule 26 (EXPR -> EXPR minus EXPR .)
    end             reduce using rule 26 (EXPR -> EXPR minus EXPR .)
    then_tok        reduce using rule 26 (EXPR -> EXPR minus EXPR .)
    do              reduce using rule 26 (EXPR -> EXPR minus EXPR .)
    times           shift and go to state 27
    divide          shift and go to state 28

  ! times           [ reduce using rule 26 (EXPR -> EXPR minus EXPR .) ]
  ! divide          [ reduce using rule 26 (EXPR -> EXPR minus EXPR .) ]
  ! plus            [ shift and go to state 25 ]
  ! minus           [ shift and go to state 26 ]


state 38

    (27) EXPR -> EXPR times EXPR .
    (25) EXPR -> EXPR . plus EXPR
    (26) EXPR -> EXPR . minus EXPR
    (27) EXPR -> EXPR . times EXPR
    (28) EXPR -> EXPR . divide EXPR

    less            reduce using rule 27 (EXPR -> EXPR times EXPR .)
    equals          reduce using rule 27 (EXPR -> EXPR times EXPR .)
    great           reduce using rule 27 (EXPR -> EXPR times EXPR .)
    plus            reduce using rule 27 (EXPR -> EXPR times EXPR .)
    minus           reduce using rule 27 (EXPR -> EXPR times EXPR .)
    times           reduce using rule 27 (EXPR -> EXPR times EXPR .)
    divide          reduce using rule 27 (EXPR -> EXPR times EXPR .)
    newline         reduce using rule 27 (EXPR -> EXPR times EXPR .)
    if              reduce using rule 27 (EXPR -> EXPR times EXPR .)
    while           reduce using rule 27 (EXPR -> EXPR times EXPR .)
    name            reduce using rule 27 (EXPR -> EXPR times EXPR .)
    $end            reduce using rule 27 (EXPR -> EXPR times EXPR .)
    elsif           reduce using rule 27 (EXPR -> EXPR times EXPR .)
    else            reduce using rule 27 (EXPR -> EXPR times EXPR .)
    end             reduce using rule 27 (EXPR -> EXPR times EXPR .)
    then_tok        reduce using rule 27 (EXPR -> EXPR times EXPR .)
    do              reduce using rule 27 (EXPR -> EXPR times EXPR .)

  ! plus            [ shift and go to state 25 ]
  ! minus           [ shift and go to state 26 ]
  ! times           [ shift and go to state 27 ]
  ! divide          [ shift and go to state 28 ]


state 39

    (28) EXPR -> EXPR divide EXPR .
    (25) EXPR -> EXPR . plus EXPR
    (26) EXPR -> EXPR . minus EXPR
    (27) EXPR -> EXPR . times EXPR
    (28) EXPR -> EXPR . divide EXPR

    less            reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    equals          reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    great           reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    plus            reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    minus           reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    times           reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    divide          reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    newline         reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    if              reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    while           reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    name            reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    $end            reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    elsif           reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    else            reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    end             reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    then_tok        reduce using rule 28 (EXPR -> EXPR divide EXPR .)
    do              reduce using rule 28 (EXPR -> EXPR divide EXPR .)

  ! plus            [ shift and go to state 25 ]
  ! minus           [ shift and go to state 26 ]
  ! times           [ shift and go to state 27 ]
  ! divide          [ shift and go to state 28 ]


state 40

    (31) ITER -> while LABELMAKER CONDEXPR do . T BLOCKSTMT T end LABELMAKER
    (6) T -> . newline
    (7) T -> .

    newline         shift and go to state 42
    if              reduce using rule 7 (T -> .)
    while           reduce using rule 7 (T -> .)
    name            reduce using rule 7 (T -> .)

    T                              shift and go to state 46

state 41

    (11) SELECT -> if CONDEXPR EMPTQC then_tok T . BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER
    (2) BLOCKSTMT -> . STMT newline BLOCKSTMT
    (3) BLOCKSTMT -> . STMT newline
    (4) BLOCKSTMT -> . STMT
    (5) BLOCKSTMT -> . STMT BLOCKSTMT
    (8) STMT -> . ASSGN
    (9) STMT -> . SELECT
    (10) STMT -> . ITER
    (23) ASSGN -> . LHS equals EXPR
    (11) SELECT -> . if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER
    (31) ITER -> . while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER
    (24) LHS -> . name

    if              shift and go to state 8
    while           shift and go to state 9
    name            shift and go to state 10

    BLOCKSTMT                      shift and go to state 47
    STMT                           shift and go to state 3
    ASSGN                          shift and go to state 4
    SELECT                         shift and go to state 5
    ITER                           shift and go to state 6
    LHS                            shift and go to state 7

state 42

    (6) T -> newline .

    if              reduce using rule 6 (T -> newline .)
    while           reduce using rule 6 (T -> newline .)
    name            reduce using rule 6 (T -> newline .)
    end             reduce using rule 6 (T -> newline .)
    elsif           reduce using rule 6 (T -> newline .)
    else            reduce using rule 6 (T -> newline .)


state 43

    (22) CONDEXPR -> EXPR less equals EXPR .
    (25) EXPR -> EXPR . plus EXPR
    (26) EXPR -> EXPR . minus EXPR
    (27) EXPR -> EXPR . times EXPR
    (28) EXPR -> EXPR . divide EXPR

    then_tok        reduce using rule 22 (CONDEXPR -> EXPR less equals EXPR .)
    do              reduce using rule 22 (CONDEXPR -> EXPR less equals EXPR .)
    plus            shift and go to state 25
    minus           shift and go to state 26
    times           shift and go to state 27
    divide          shift and go to state 28


state 44

    (19) CONDEXPR -> EXPR equals equals EXPR .
    (25) EXPR -> EXPR . plus EXPR
    (26) EXPR -> EXPR . minus EXPR
    (27) EXPR -> EXPR . times EXPR
    (28) EXPR -> EXPR . divide EXPR

    then_tok        reduce using rule 19 (CONDEXPR -> EXPR equals equals EXPR .)
    do              reduce using rule 19 (CONDEXPR -> EXPR equals equals EXPR .)
    plus            shift and go to state 25
    minus           shift and go to state 26
    times           shift and go to state 27
    divide          shift and go to state 28


state 45

    (21) CONDEXPR -> EXPR great equals EXPR .
    (25) EXPR -> EXPR . plus EXPR
    (26) EXPR -> EXPR . minus EXPR
    (27) EXPR -> EXPR . times EXPR
    (28) EXPR -> EXPR . divide EXPR

    then_tok        reduce using rule 21 (CONDEXPR -> EXPR great equals EXPR .)
    do              reduce using rule 21 (CONDEXPR -> EXPR great equals EXPR .)
    plus            shift and go to state 25
    minus           shift and go to state 26
    times           shift and go to state 27
    divide          shift and go to state 28


state 46

    (31) ITER -> while LABELMAKER CONDEXPR do T . BLOCKSTMT T end LABELMAKER
    (2) BLOCKSTMT -> . STMT newline BLOCKSTMT
    (3) BLOCKSTMT -> . STMT newline
    (4) BLOCKSTMT -> . STMT
    (5) BLOCKSTMT -> . STMT BLOCKSTMT
    (8) STMT -> . ASSGN
    (9) STMT -> . SELECT
    (10) STMT -> . ITER
    (23) ASSGN -> . LHS equals EXPR
    (11) SELECT -> . if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER
    (31) ITER -> . while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER
    (24) LHS -> . name

    if              shift and go to state 8
    while           shift and go to state 9
    name            shift and go to state 10

    BLOCKSTMT                      shift and go to state 48
    STMT                           shift and go to state 3
    ASSGN                          shift and go to state 4
    SELECT                         shift and go to state 5
    ITER                           shift and go to state 6
    LHS                            shift and go to state 7

state 47

    (11) SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT . LABELMAKER T ELSIF ELSE end LABELMAKER
    (13) LABELMAKER -> .

    newline         reduce using rule 13 (LABELMAKER -> .)
    elsif           reduce using rule 13 (LABELMAKER -> .)
    else            reduce using rule 13 (LABELMAKER -> .)
    end             reduce using rule 13 (LABELMAKER -> .)

    LABELMAKER                     shift and go to state 49

state 48

    (31) ITER -> while LABELMAKER CONDEXPR do T BLOCKSTMT . T end LABELMAKER
    (6) T -> . newline
    (7) T -> .

    newline         shift and go to state 42
    end             reduce using rule 7 (T -> .)

    T                              shift and go to state 50

state 49

    (11) SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER . T ELSIF ELSE end LABELMAKER
    (6) T -> . newline
    (7) T -> .

    newline         shift and go to state 42
    elsif           reduce using rule 7 (T -> .)
    else            reduce using rule 7 (T -> .)
    end             reduce using rule 7 (T -> .)

    T                              shift and go to state 51

state 50

    (31) ITER -> while LABELMAKER CONDEXPR do T BLOCKSTMT T . end LABELMAKER

    end             shift and go to state 52


state 51

    (11) SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T . ELSIF ELSE end LABELMAKER
    (14) ELSIF -> . elsif CONDEXPR then_tok T BLOCKSTMT LABELMAKER
    (15) ELSIF -> .

    elsif           shift and go to state 54
    else            reduce using rule 15 (ELSIF -> .)
    end             reduce using rule 15 (ELSIF -> .)

    ELSIF                          shift and go to state 53

state 52

    (31) ITER -> while LABELMAKER CONDEXPR do T BLOCKSTMT T end . LABELMAKER
    (13) LABELMAKER -> .

    newline         reduce using rule 13 (LABELMAKER -> .)
    if              reduce using rule 13 (LABELMAKER -> .)
    while           reduce using rule 13 (LABELMAKER -> .)
    name            reduce using rule 13 (LABELMAKER -> .)
    $end            reduce using rule 13 (LABELMAKER -> .)
    elsif           reduce using rule 13 (LABELMAKER -> .)
    else            reduce using rule 13 (LABELMAKER -> .)
    end             reduce using rule 13 (LABELMAKER -> .)

    LABELMAKER                     shift and go to state 55

state 53

    (11) SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF . ELSE end LABELMAKER
    (16) ELSE -> . else BLOCKSTMT
    (17) ELSE -> .

    else            shift and go to state 57
    end             reduce using rule 17 (ELSE -> .)

    ELSE                           shift and go to state 56

state 54

    (14) ELSIF -> elsif . CONDEXPR then_tok T BLOCKSTMT LABELMAKER
    (18) CONDEXPR -> . EXPR less EXPR
    (19) CONDEXPR -> . EXPR equals equals EXPR
    (20) CONDEXPR -> . EXPR great EXPR
    (21) CONDEXPR -> . EXPR great equals EXPR
    (22) CONDEXPR -> . EXPR less equals EXPR
    (25) EXPR -> . EXPR plus EXPR
    (26) EXPR -> . EXPR minus EXPR
    (27) EXPR -> . EXPR times EXPR
    (28) EXPR -> . EXPR divide EXPR
    (29) EXPR -> . name
    (30) EXPR -> . number

    name            shift and go to state 16
    number          shift and go to state 17

    CONDEXPR                       shift and go to state 58
    EXPR                           shift and go to state 15

state 55

    (31) ITER -> while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER .

    newline         reduce using rule 31 (ITER -> while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER .)
    if              reduce using rule 31 (ITER -> while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER .)
    while           reduce using rule 31 (ITER -> while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER .)
    name            reduce using rule 31 (ITER -> while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER .)
    $end            reduce using rule 31 (ITER -> while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER .)
    elsif           reduce using rule 31 (ITER -> while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER .)
    else            reduce using rule 31 (ITER -> while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER .)
    end             reduce using rule 31 (ITER -> while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER .)


state 56

    (11) SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE . end LABELMAKER

    end             shift and go to state 59


state 57

    (16) ELSE -> else . BLOCKSTMT
    (2) BLOCKSTMT -> . STMT newline BLOCKSTMT
    (3) BLOCKSTMT -> . STMT newline
    (4) BLOCKSTMT -> . STMT
    (5) BLOCKSTMT -> . STMT BLOCKSTMT
    (8) STMT -> . ASSGN
    (9) STMT -> . SELECT
    (10) STMT -> . ITER
    (23) ASSGN -> . LHS equals EXPR
    (11) SELECT -> . if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER
    (31) ITER -> . while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER
    (24) LHS -> . name

    if              shift and go to state 8
    while           shift and go to state 9
    name            shift and go to state 10

    BLOCKSTMT                      shift and go to state 60
    STMT                           shift and go to state 3
    ASSGN                          shift and go to state 4
    SELECT                         shift and go to state 5
    ITER                           shift and go to state 6
    LHS                            shift and go to state 7

state 58

    (14) ELSIF -> elsif CONDEXPR . then_tok T BLOCKSTMT LABELMAKER

    then_tok        shift and go to state 61


state 59

    (11) SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end . LABELMAKER
    (13) LABELMAKER -> .

    newline         reduce using rule 13 (LABELMAKER -> .)
    if              reduce using rule 13 (LABELMAKER -> .)
    while           reduce using rule 13 (LABELMAKER -> .)
    name            reduce using rule 13 (LABELMAKER -> .)
    $end            reduce using rule 13 (LABELMAKER -> .)
    elsif           reduce using rule 13 (LABELMAKER -> .)
    else            reduce using rule 13 (LABELMAKER -> .)
    end             reduce using rule 13 (LABELMAKER -> .)

    LABELMAKER                     shift and go to state 62

state 60

    (16) ELSE -> else BLOCKSTMT .

    end             reduce using rule 16 (ELSE -> else BLOCKSTMT .)


state 61

    (14) ELSIF -> elsif CONDEXPR then_tok . T BLOCKSTMT LABELMAKER
    (6) T -> . newline
    (7) T -> .

    newline         shift and go to state 42
    if              reduce using rule 7 (T -> .)
    while           reduce using rule 7 (T -> .)
    name            reduce using rule 7 (T -> .)

    T                              shift and go to state 63

state 62

    (11) SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER .

    newline         reduce using rule 11 (SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER .)
    if              reduce using rule 11 (SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER .)
    while           reduce using rule 11 (SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER .)
    name            reduce using rule 11 (SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER .)
    $end            reduce using rule 11 (SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER .)
    elsif           reduce using rule 11 (SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER .)
    else            reduce using rule 11 (SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER .)
    end             reduce using rule 11 (SELECT -> if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER .)


state 63

    (14) ELSIF -> elsif CONDEXPR then_tok T . BLOCKSTMT LABELMAKER
    (2) BLOCKSTMT -> . STMT newline BLOCKSTMT
    (3) BLOCKSTMT -> . STMT newline
    (4) BLOCKSTMT -> . STMT
    (5) BLOCKSTMT -> . STMT BLOCKSTMT
    (8) STMT -> . ASSGN
    (9) STMT -> . SELECT
    (10) STMT -> . ITER
    (23) ASSGN -> . LHS equals EXPR
    (11) SELECT -> . if CONDEXPR EMPTQC then_tok T BLOCKSTMT LABELMAKER T ELSIF ELSE end LABELMAKER
    (31) ITER -> . while LABELMAKER CONDEXPR do T BLOCKSTMT T end LABELMAKER
    (24) LHS -> . name

    if              shift and go to state 8
    while           shift and go to state 9
    name            shift and go to state 10

    BLOCKSTMT                      shift and go to state 64
    STMT                           shift and go to state 3
    ASSGN                          shift and go to state 4
    SELECT                         shift and go to state 5
    ITER                           shift and go to state 6
    LHS                            shift and go to state 7

state 64

    (14) ELSIF -> elsif CONDEXPR then_tok T BLOCKSTMT . LABELMAKER
    (13) LABELMAKER -> .

    else            reduce using rule 13 (LABELMAKER -> .)
    end             reduce using rule 13 (LABELMAKER -> .)

    LABELMAKER                     shift and go to state 65

state 65

    (14) ELSIF -> elsif CONDEXPR then_tok T BLOCKSTMT LABELMAKER .

    else            reduce using rule 14 (ELSIF -> elsif CONDEXPR then_tok T BLOCKSTMT LABELMAKER .)
    end             reduce using rule 14 (ELSIF -> elsif CONDEXPR then_tok T BLOCKSTMT LABELMAKER .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for newline in state 3 resolved as shift
